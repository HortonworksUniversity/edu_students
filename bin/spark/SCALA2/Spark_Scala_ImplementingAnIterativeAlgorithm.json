{"paragraphs":[{"text":"%md\n# About This Lab\n**Objective:** Implement the K-Means algorithm in Spark\n**File locations:** /devsh_loudacre/devicestatus_etl\n**Successful outcome:**\n**Before you begin:**\n**Related lessons:** Common Patterns in Spark Data Processing\n\n---","user":"anonymous","dateUpdated":"2020-01-13T22:28:43-0800","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true,"completionSupport":false},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"fontSize":9,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1578981897661_-699842793","id":"20171105-200834_1116095891","dateCreated":"2020-01-13T22:04:57-0800","dateStarted":"2020-01-13T22:29:20-0800","dateFinished":"2020-01-13T22:29:20-0800","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:95404"},{"text":"%md\n# Setup\n---\n\nThe following cells allow this notebook to run without errors from top to bottom any number of times.","user":"anonymous","dateUpdated":"2020-01-13T22:28:43-0800","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true,"completionKey":"TAB","completionSupport":false},"colWidth":12,"editorMode":"ace/mode/markdown","fontSize":9,"editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1578981897662_-629322344","id":"20181114-164229_902436001","dateCreated":"2020-01-13T22:04:57-0800","dateStarted":"2020-01-13T22:29:20-0800","dateFinished":"2020-01-13T22:29:20-0800","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:95405"},{"text":"%sh\n\nhdfs dfs -rm -r -f /devsh_loudacre/devicestatus.txt\nhdfs dfs -rm -r -f /devsh_loudacre/devicestatus_etl\nhdfs dfs -put /home/training/training_materials/devsh/data/devicestatus.txt /devsh_loudacre","user":"anonymous","dateUpdated":"2020-01-13T22:28:43-0800","config":{"editorSetting":{"language":"sh","editOnDblClick":false,"completionKey":"TAB","completionSupport":false},"colWidth":12,"editorMode":"ace/mode/sh","fontSize":9,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1578981897663_1985255465","id":"20200113-205353_1067217385","dateCreated":"2020-01-13T22:04:57-0800","dateStarted":"2020-01-13T22:29:20-0800","dateFinished":"2020-01-13T22:29:28-0800","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:95406"},{"text":"%spark\n\n// Load the data file\nval devstatus = sc.textFile(\"/devsh_loudacre/devicestatus.txt\")\n\n// Filter out lines with < 20 characters, use the 20th character as the delimiter, parse the line, and filter out bad lines\nval cleanstatus = devstatus.\n    filter(line => line.length>20).\n    map(line => line.split(line.charAt(19))).\n    filter(values => values.length == 14)\n    \n// Create a new RDD containing date, manufacturer, device ID, latitude and longitude\nval devicedata = cleanstatus.map(values => (values(0), values(1).split(' ')(0), values(2), values(12), values(13)))\n\n// Save to a CSV file as a comma-delimited string (trim parenthesis from tuple toString)\ndevicedata.map(values => values.toString).map(s => s.substring(1,s.length-1)).saveAsTextFile(\"/devsh_loudacre/devicestatus_etl\")","user":"anonymous","dateUpdated":"2020-01-13T22:28:51-0800","config":{"editorSetting":{"language":"scala","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/scala","fontSize":9,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1578981897665_1833440609","id":"20200113-205717_1293024784","dateCreated":"2020-01-13T22:04:57-0800","dateStarted":"2020-01-13T22:29:28-0800","dateFinished":"2020-01-13T22:29:28-0800","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:95407"},{"text":"%md\nExamine the data in the dataset.\nNote that the latitude and longitude are the 4th and 5th fields, respectively, as shown in the sample data below:\n\n2014-03-15:10:10:20,Sorrento,8cc3b47e-bd01-4482-b500- 28f2342679af, **33.6894754264**, **-117.543308253**\n2014-03-15:10:10:20,MeeToo,ef8c7564-0a1a-4650-a655- c8bbd5f8f943,37. **4321088904**, **-121.485029632**","user":"anonymous","dateUpdated":"2020-01-13T22:28:52-0800","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true,"completionKey":"TAB","completionSupport":false},"colWidth":12,"editorMode":"ace/mode/markdown","fontSize":9,"editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1578981897666_75634642","id":"20200113-210656_1039383259","dateCreated":"2020-01-13T22:04:57-0800","dateStarted":"2020-01-13T22:29:28-0800","dateFinished":"2020-01-13T22:29:28-0800","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:95408"},{"text":"%md\n# Lab\n---","user":"anonymous","dateUpdated":"2020-01-13T22:28:52-0800","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true,"completionKey":"TAB","completionSupport":false},"colWidth":12,"editorMode":"ace/mode/markdown","fontSize":9,"editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1578981897667_454268551","id":"20181114-164844_1661453681","dateCreated":"2020-01-13T22:04:57-0800","dateStarted":"2020-01-13T22:29:28-0800","dateFinished":"2020-01-13T22:29:28-0800","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:95409"},{"text":"%md\n### Calculating k-means for Device Location\n\nStart by copying the following code.\n\n```spark\nimport scala.math.pow\n\n// The squared distances between two points\ndef distanceSquared(p1: (Double,Double), p2: (Double,Double)) = { \n  pow(p1._1 - p2._1,2) + pow(p1._2 - p2._2,2 )\n}\n\n// The sum of two points\ndef addPoints(p1: (Double,Double), p2: (Double,Double)) = {\n  (p1._1 + p2._1, p1._2 + p2._2)\n}\n\n// for a point p and an array of points, return the index in the array of the point closest to p\ndef closestPoint(p: (Double,Double), points: Array[(Double,Double)]): Int = {\n    var index = 0\n    var bestIndex = 0\n    var closest = Double.PositiveInfinity\n\n    for (i <- 0 until points.length) {\n      val dist = distanceSquared(p,points(i))\n      if (dist < closest) {\n        closest = dist\n        bestIndex = i\n      }\n    }\n    bestIndex\n}\n\n// The device status dataset\nval filename = \"/devsh_loudacre/devicestatus_etl\"\n\n// K is the number of means (center points of clusters) to find\nval K = 5\n\n// ConvergeDist -- the threshold \"distance\" between iterations at which we decide we are done\nval convergeDist = .01\n\n\n```\n\nThis starter code defines convenience functions used in calculating k-means:\n \n* closestPoint: given a (latitude/longitude) point and an array of current center points, returns the index in the array of the center closest to the given point\n* addPoints: given two points, return a point which is the sum of the two points —that is, (x1+x2, y1+y2)\n* distanceSquared: given two points, returns the squared distance of the two —this is a common calculation required in graph analysis\n* Note that the stub code sets the variable K equal to 5—this is the number of means to calculate.\n* The stub code also sets the variable convergeDist. This will be used to decide when the k-means calculation is done—when the amount the locations of the means changes between iterations is less than convergeDist. \nA “perfect” solution would be 0; this number represents a “good enough” solution. For this exercise, use a value of 0.01.","user":"anonymous","dateUpdated":"2020-01-13T22:28:52-0800","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true,"completionKey":"TAB","completionSupport":false},"colWidth":12,"editorMode":"ace/mode/markdown","fontSize":9,"editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1578981897668_-2003975399","id":"20200113-211417_691352266","dateCreated":"2020-01-13T22:04:57-0800","dateStarted":"2020-01-13T22:29:29-0800","dateFinished":"2020-01-13T22:29:29-0800","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:95410"},{"title":"1 - Define convenience functions","text":"%spark\n","user":"anonymous","dateUpdated":"2020-01-13T22:28:53-0800","config":{"editorSetting":{"language":"scala","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/scala","fontSize":9,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1578981897669_679608999","id":"20200113-211631_1084007442","dateCreated":"2020-01-13T22:04:57-0800","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:95411"},{"text":"%md\nParse the input file—which is delimited by commas—into (latitude,longitude) pairs (the 4th and 5th fields in each line).\nOnly include known locations—that is, filter out (0,0) locations. \nBe sure to persist the resulting RDD because you will access it each time through the iteration.","user":"anonymous","dateUpdated":"2020-01-13T22:28:53-0800","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true,"completionKey":"TAB","completionSupport":false},"colWidth":12,"editorMode":"ace/mode/markdown","fontSize":9,"editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1578981897670_-1145334741","id":"20200113-212735_1440150758","dateCreated":"2020-01-13T22:04:57-0800","dateStarted":"2020-01-13T22:29:29-0800","dateFinished":"2020-01-13T22:29:29-0800","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:95412"},{"title":"2 - Parse the input file into (latitude,longitude) pairs","text":"%spark\n","user":"anonymous","dateUpdated":"2020-01-13T22:28:53-0800","config":{"editorSetting":{"language":"scala","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/scala","fontSize":9,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1578981897671_369009925","id":"20200113-212857_1641904988","dateCreated":"2020-01-13T22:04:57-0800","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:95413"},{"text":"%md\nCreate a K-length array called kPoints by taking a random sample of K location points from the RDD as starting means (center points).\n\n```pyspark\nval kPoints = points.takeSample(false, K, 42)\n```","user":"anonymous","dateUpdated":"2020-01-13T22:28:53-0800","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true,"completionKey":"TAB","completionSupport":false},"colWidth":12,"editorMode":"ace/mode/markdown","fontSize":9,"editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1578981897672_-175092713","id":"20200113-213436_996816824","dateCreated":"2020-01-13T22:04:57-0800","dateStarted":"2020-01-13T22:29:29-0800","dateFinished":"2020-01-13T22:29:29-0800","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:95414"},{"title":"3 - Create a K-length array called kPoints by taking a random sample of K location points","text":"%spark\n","user":"anonymous","dateUpdated":"2020-01-13T22:28:53-0800","config":{"editorSetting":{"language":"scala","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/scala","fontSize":9,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1578981897673_107380748","id":"20200113-213432_1475725827","dateCreated":"2020-01-13T22:04:57-0800","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:95415"},{"text":"%md\nInitialize a variable called tempDist to positive infinity. The variable with be used to determine when to complete the conditional loop in the next step.\n\n```spark\nvar tempDist = Double.PositiveInfinity\n```","user":"anonymous","dateUpdated":"2020-01-13T22:28:53-0800","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true,"completionKey":"TAB","completionSupport":false},"colWidth":12,"editorMode":"ace/mode/markdown","fontSize":9,"editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1578981897674_27310614","id":"20200113-213953_97782877","dateCreated":"2020-01-13T22:04:57-0800","dateStarted":"2020-01-13T22:29:29-0800","dateFinished":"2020-01-13T22:29:29-0800","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:95416"},{"title":"4 - Initialize a variable called tempDist to positive infinity","text":"%spark\n","user":"anonymous","dateUpdated":"2020-01-13T22:28:53-0800","config":{"editorSetting":{"language":"scala","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/scala","fontSize":9,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1578981897675_-1651611998","id":"20200113-213950_1804304671","dateCreated":"2020-01-13T22:04:57-0800","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:95417"},{"text":"%md\nIteratively calculate a new set of K means until the total distance (stored as tempDist) between the means calculated for this iteration and the last one is smaller than convergeDist.\n\nFor each iteration:\n\n1. For each coordinate point, use the provided closestPoint function to map that point to the index in the kPoints array of the location closest to that point.\nThe resulting RDD should be keyed by the index, and the value should be the pair: (point, 1). (The value 1 will later be used to count the number of points closest to a given mean.)\nFor example:\n```\n(1, ((37.43210, -121.48502), 1))\n(4, ((33.11310, -111.33201), 1))\n(0, ((39.36351, -119.40003), 1))\n(1, ((40.00019, -116.44829), 1))\n...\n```\n2. Reduce the result: for each center in the kPoints array, sum the latitudes and longitudes, respectively, of all the points closest to that center, and also find the number of closest points.\nFor example:\n```\n(0, ((2638919.87653,-8895032.182481), 74693)))\n(1, ((3654635.24961,-12197518.55688), 101268)))\n(2, ((1863384.99784,-5839621.052003), 48620)))\n(3, ((4887181.82600,-14674125.94873), 126114)))\n(4, ((2866039.85637,-9608816.13682), 81162)))\n```\n\n3. The reduced RDD should have (at most) K members. Map each to a new center point by calculating the average latitude and longitude for each set of closest points: that is, map (index,(totalX,totalY),n) to (index,(totalX/ n, totalY/n)).\n4. Collect these new points into a local map or array keyed by index.\n5. Use the provided distanceSquared method to calculate how much the centers “moved” between the current iteration and the last. That is, for each center in kPoints, calculate the distance between that point and the corresponding new point, and sum those distances. That sum is the delta between iterations; when the delta is less than convergeDist, stop iterating.\n6. Copy the new center points to the kPoints array in preparation for the next iteration.","user":"anonymous","dateUpdated":"2020-01-13T22:28:53-0800","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true,"completionKey":"TAB","completionSupport":false},"colWidth":12,"editorMode":"ace/mode/markdown","fontSize":9,"editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1578981897676_323609806","id":"20200113-214436_1651314759","dateCreated":"2020-01-13T22:04:57-0800","dateStarted":"2020-01-13T22:29:29-0800","dateFinished":"2020-01-13T22:29:29-0800","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:95418"},{"title":"5 - Iteratively calculate a new set of K means","text":"%spark\n","user":"anonymous","dateUpdated":"2020-01-13T22:28:53-0800","config":{"editorSetting":{"language":"scala","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/scala","fontSize":9,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1578981897677_-2114282629","id":"20200113-215343_1093190859","dateCreated":"2020-01-13T22:04:57-0800","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:95419"},{"text":"%md\n# Result\n**You have now:** practiced implementing iterative algorithms in Spark by calculating k-means for a set of points.\n\n\n---","user":"anonymous","dateUpdated":"2020-01-13T22:28:53-0800","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true,"completionKey":"TAB","completionSupport":false},"colWidth":12,"editorMode":"ace/mode/markdown","fontSize":9,"editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1578981897678_87159191","id":"20181119-142716_792318228","dateCreated":"2020-01-13T22:04:57-0800","dateStarted":"2020-01-13T22:29:29-0800","dateFinished":"2020-01-13T22:29:29-0800","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:95420"},{"text":"%md\n# Solution\n---","user":"anonymous","dateUpdated":"2020-01-13T22:28:53-0800","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true,"completionKey":"TAB","completionSupport":false},"colWidth":12,"editorMode":"ace/mode/markdown","fontSize":9,"editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1578981897679_-1820013499","id":"20171113-155535_1769142099","dateCreated":"2020-01-13T22:04:57-0800","dateStarted":"2020-01-13T22:29:29-0800","dateFinished":"2020-01-13T22:29:29-0800","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:95421"},{"title":"1 - Define convenience functions","text":"%spark\n\nimport scala.math.pow\n\n// The squared distances between two points\ndef distanceSquared(p1: (Double,Double), p2: (Double,Double)) = { \n  pow(p1._1 - p2._1,2) + pow(p1._2 - p2._2,2 )\n}\n\n// The sum of two points\ndef addPoints(p1: (Double,Double), p2: (Double,Double)) = {\n  (p1._1 + p2._1, p1._2 + p2._2)\n}\n\n// for a point p and an array of points, return the index in the array of the point closest to p\ndef closestPoint(p: (Double,Double), points: Array[(Double,Double)]): Int = {\n    var index = 0\n    var bestIndex = 0\n    var closest = Double.PositiveInfinity\n\n    for (i <- 0 until points.length) {\n      val dist = distanceSquared(p,points(i))\n      if (dist < closest) {\n        closest = dist\n        bestIndex = i\n      }\n    }\n    bestIndex\n}\n\n// The device status dataset\nval filename = \"/devsh_loudacre/devicestatus_etl\"\n\n// K is the number of means (center points of clusters) to find\nval K = 5\n\n// ConvergeDist -- the threshold \"distance\" between iterations at which we decide we are done\nval convergeDist = .01\n\n","user":"anonymous","dateUpdated":"2020-01-13T22:28:54-0800","config":{"editorSetting":{"language":"scala","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/scala","fontSize":9,"editorHide":false,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1578981897680_-181327161","id":"20200113-212301_1748967338","dateCreated":"2020-01-13T22:04:57-0800","dateStarted":"2020-01-13T22:29:29-0800","dateFinished":"2020-01-13T22:29:29-0800","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:95422"},{"title":"2 - Parse the input file into (latitude,longitude) pairs","text":"%spark\n\nval points = sc.textFile(filename).\n     map(line => line.split(',')).\n     map(fields => (fields(3).toDouble,fields(4).toDouble)).\n     filter(point => (point._1 != 0) && (point._2 != 0)).\n     persist()","user":"anonymous","dateUpdated":"2020-01-13T22:28:54-0800","config":{"editorSetting":{"language":"scala","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/scala","fontSize":9,"editorHide":false,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1578981897681_-1870002814","id":"20200113-212956_797754734","dateCreated":"2020-01-13T22:04:57-0800","dateStarted":"2020-01-13T22:29:30-0800","dateFinished":"2020-01-13T22:29:30-0800","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:95423"},{"title":"3 - Create a K-length array called kPoints by taking a random sample of K location points","text":"%spark\n\nval kPoints = points.takeSample(false, K, 42)","user":"anonymous","dateUpdated":"2020-01-13T22:28:55-0800","config":{"editorSetting":{"language":"scala","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/scala","fontSize":9,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1578981897682_680441382","id":"20200113-213644_847195594","dateCreated":"2020-01-13T22:04:57-0800","dateStarted":"2020-01-13T22:29:30-0800","dateFinished":"2020-01-13T22:29:30-0800","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:95424"},{"title":"4 - Initialize a variable called tempDist to positive infinity","text":"%spark\n\nvar tempDist = Double.PositiveInfinity","user":"anonymous","dateUpdated":"2020-01-13T22:28:55-0800","config":{"editorSetting":{"language":"scala","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/scala","fontSize":9,"editorHide":false,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1578981897683_512785622","id":"20200113-214150_1110119797","dateCreated":"2020-01-13T22:04:57-0800","dateStarted":"2020-01-13T22:29:30-0800","dateFinished":"2020-01-13T22:29:31-0800","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:95425"},{"title":"5 - Iteratively calculate a new set of K means","text":"%spark\n\nprintln(\"Starting K points:\")\nkPoints.foreach(println) \n\n// loop until the total distance between one iteration's points and the next is less than the convergence distance specified\nvar tempDist = Double.PositiveInfinity\nwhile (tempDist > convergeDist) {\n\n    // for each point, find the index of the closest kpoint.  map to (index, (point,1))\n    val closest = points.map(p => (closestPoint(p, kPoints), (p, 1)))\n    \n    // For each key (k-point index), reduce by adding the coordinates and number of points\n    val pointStats = closest.reduceByKey{case ((point1,n1),(point2,n2)) => (addPoints(point1,point2),n1+n2) }\n\n    // For each key (k-point index), find a new point by calculating the average of each closest point\n    val newPoints = pointStats.map{case (i,(point,n)) => (i,(point._1/n,point._2/n))}.collectAsMap()\n    \n    // calculate the total of the distance between the current points and new points\n    tempDist = 0.0\n    for (i <- 0 until K) {\n      tempDist += distanceSquared(kPoints(i),newPoints(i))\n    }\n    println(\"Distance between iterations: \"+tempDist)\n\n    // Copy the new points to the kPoints array for the next iteration\n    for (i <- 0 until K) {\n      kPoints(i) = newPoints(i)\n    }\n}\n   \n// Display the final center points        \nprintln(\"Final K points: \" )\nkPoints.foreach(println)\n","user":"anonymous","dateUpdated":"2020-01-13T22:28:55-0800","config":{"editorSetting":{"language":"scala","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/scala","fontSize":9,"editorHide":false,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1578981897684_2045112256","id":"20200113-215544_1965818472","dateCreated":"2020-01-13T22:04:57-0800","dateStarted":"2020-01-13T22:29:31-0800","dateFinished":"2020-01-13T22:29:32-0800","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:95426"},{"title":"Additional resources","text":"%md\nWe hope you've enjoyed this lab. Below are additional resources that you should find useful:\n\n1. [Cloudera Tutorials](http://cloudera.com/tutorials.html) are your natural next step where you can explore Spark in more depth.\n2. [Cloudera Community](https://community.cloudera.com) is a great resource for questions and answers on Spark, Data Analytics/Science, and many more Big Data topics.\n3. [Apache Spark Documentation](https://spark.apache.org/documentation.html) - official Spark documentation.\n4. [Apache Zeppelin Project Home Page](https://zeppelin.apache.org) - official Zeppelin web site.","user":"anonymous","dateUpdated":"2020-01-13T22:28:57-0800","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true,"completionKey":"TAB","completionSupport":false},"colWidth":10,"editorMode":"ace/mode/markdown","fontSize":9,"editorHide":true,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1578981897685_-1797552630","id":"20181116-135131_93712280","dateCreated":"2020-01-13T22:04:57-0800","dateStarted":"2020-01-13T22:29:32-0800","dateFinished":"2020-01-13T22:29:32-0800","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:95427"},{"text":"%angular\n</br>\n</br>\n</br>\n</br>\n<center>\n<a href=\"https://www.cloudera.com/about/training/courses.html\">\n  <img src=\"https://www.cloudera.com/content/dam/www/marketing/media-kit/logo-assets/cloudera_logo_darkorange.png\" alt=\"Cloudera University\" style=\"width:280px;height:40px;border:0;\" align=\"middle\">\n</a>\n</center>\n</br>\n</br>","user":"anonymous","dateUpdated":"2020-01-13T22:28:57-0800","config":{"tableHide":false,"editorSetting":{"language":"scala","editOnDblClick":true,"completionKey":"TAB","completionSupport":false},"colWidth":2,"editorMode":"ace/mode/undefined","fontSize":9,"editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1578981897686_488286203","id":"20200110-154537_1406191376","dateCreated":"2020-01-13T22:04:57-0800","dateStarted":"2020-01-13T22:29:32-0800","dateFinished":"2020-01-13T22:29:32-0800","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:95428"},{"text":"%angular\n","user":"anonymous","dateUpdated":"2020-01-13T22:28:57-0800","config":{"editorSetting":{"language":"scala","editOnDblClick":true,"completionKey":"TAB","completionSupport":false},"colWidth":12,"editorMode":"ace/mode/undefined","fontSize":9,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1578981897688_1067969295","id":"20200110-162013_302547143","dateCreated":"2020-01-13T22:04:57-0800","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:95429"}],"name":"Labs/Scala/ImplementingAnIterativeAlgorithm","id":"2EZ41PBDD","noteParams":{},"noteForms":{},"angularObjects":{"md:shared_process":[],"angular:shared_process":[],"sh:shared_process":[],"spark:shared_process":[]},"config":{"isZeppelinNotebookCronEnable":false,"looknfeel":"default","personalizedMode":"false"},"info":{}}